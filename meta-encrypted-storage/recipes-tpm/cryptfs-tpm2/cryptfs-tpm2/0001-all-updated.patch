diff -ur --new-file '--exclude=.git' a/scripts/encrypt_secret.py.in d/scripts/encrypt_secret.py.in
--- a/scripts/encrypt_secret.py.in	2021-01-13 13:46:58.011933306 +0000
+++ d/scripts/encrypt_secret.py.in	2021-01-13 13:54:18.617382681 +0000
@@ -1,11 +1,10 @@
-#!/usr/bin/env python
+#!/usr/bin/env python3
 #coding: UTF-8
 
 '''
 The simple encryption/decryption for secret info
 '''
 
-from __future__ import print_function
 import logging
 import argparse
 import struct
diff -ur --new-file '--exclude=.git' a/scripts/init.cryptfs d/scripts/init.cryptfs
--- a/scripts/init.cryptfs	2020-12-01 15:21:10.228957565 +0000
+++ d/scripts/init.cryptfs	2021-01-13 13:54:38.389267890 +0000
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 
 # Initramfs script called by /init
 #
@@ -43,6 +43,8 @@
 # Global constant settings
 #
 
+PATH=$PATH:'/usr/sbin':'/sbin'
+
 # The tmpfs filesystem used to temporarily place the
 # passphrase file.
 TMP_DIR="/tmp"
@@ -116,7 +118,7 @@
 }
 
 get_dev_uuid() {
-    blkid -t UUID=$1 -l | awk -F: '{ print $1 }'
+    blkid -t UUID="$1" -l | awk -F: '{ print $1 }'
 }
 
 get_dev_partuuid() {
@@ -124,16 +126,16 @@
 }
 
 get_dev_label() {
-    rawdev=`blkid -t LABEL=$1 -l | awk -F: '{print $1}'`
+    rawdev=$(blkid -t LABEL="$1" -l | awk -F: '{print $1}')
     # Also try the partition label for the same name if not found
-    if [ "$rawdev" == "" ] ; then
-	rawdev=`blkid -t PARTLABEL=$1 -l | awk -F: '{ print $1 }'`
+    if [ "$rawdev" = "" ] ; then
+        rawdev=$(blkid -t PARTLABEL="$1" -l | awk -F: '{ print $1 }')
     fi
-    echo $rawdev
+    echo "$rawdev"
 }
 
 get_dev_rawdev() {
-    [ -e /sys/class/block/`basename "$1"` ] && echo $1
+    [ -e /sys/class/block/"$(basename "$1")" ] && echo "$1"
 }
 
 parse_rootfs_dev_path() {
@@ -151,13 +153,13 @@
         [ -n "$dev_name" ] && break
     done
 
-    if [ -z "$dev_name" -o -z "$dev_type" ]; then
+    if [ -z "$dev_name" ] || [ -z "$dev_type" ]; then
         print_error "Empty root= option, cannot proceed to boot!"
         return 1
     fi
 
-    [ -n "$ret_type" ] && eval $ret_type="$dev_type"
-    [ -n "$ret_name" ] && eval $ret_name="$dev_name"
+    [ -n "$ret_type" ] && eval "$ret_type"="$dev_type"
+    [ -n "$ret_name" ] && eval "$ret_name"="$dev_name"
 
     print_verbose "device path: $dev_type=$dev_name"
 
@@ -171,14 +173,14 @@
     local rawdev
 
     case "$type" in
-        UUID)     rawdev=$(get_dev_uuid $name) ;;
-        PARTUUID) rawdev=$(get_dev_partuuid $name) ;;
-        LABEL)    rawdev=$(get_dev_label $name) ;;
-        RAWDEV)   rawdev=$(get_dev_rawdev $name) ;;
+        UUID)     rawdev=$(get_dev_uuid "$name") ;;
+        PARTUUID) rawdev=$(get_dev_partuuid "$name") ;;
+        LABEL)    rawdev=$(get_dev_label "$name") ;;
+        RAWDEV)   rawdev=$(get_dev_rawdev "$name") ;;
     esac
 
     if [ -n "$rawdev" ] ; then
-        [ -n "$ret_rawdev" ] && eval $ret_rawdev="$rawdev"
+        [ -n "$ret_rawdev" ] && eval "$ret_rawdev"="$rawdev"
         print_info "Found root device: $rawdev"
         return 0
     fi
@@ -190,11 +192,10 @@
     local retry=0
 
     while [ $retry -lt $MAX_TIMEOUT_FOR_WAITING_RAWDEV ]; do
-        __get_rawdev "$1" "$2" "$3"
-        [ $? -eq 0 ] && return 0
+        __get_rawdev "$1" "$2" "$3" && return 0
 
         sleep 0.1
-        retry=$(($retry+1))
+        retry=$((retry+1))
     done
 
     print_error "Unable to find raw device for $1=$2!"
@@ -234,9 +235,9 @@
     for _name in $name_in_dev; do
         [ -c "/dev/$_name" ] && break
 
-        local major=$(cat "/sys/class/tpm/$name/dev" | cut -d ":" -f 1)
-        local minor=$(cat "/sys/class/tpm/$name/dev" | cut -d ":" -f 2)
-        ! mknod "/dev/$_name" c $major $minor &&
+        local major=$(cut -d ":" -f 1 "/sys/class/tpm/$name/dev")
+        local minor=$(cut -d ":" -f 2 "/sys/class/tpm/$name/dev")
+        ! mknod "/dev/$_name" c "$major" "$minor" &&
             print_error "Unable to create tpm device node $_name." && return 1
 
         TPM_DEVICE="/dev/$_name"
@@ -244,7 +245,7 @@
         break
     done
 
-    [ -n "$ret_absent" ] && eval $ret_absent=$tpm_absent
+    [ -n "$ret_absent" ] && eval "$ret_absent"="$tpm_absent"
 
     print_info "TPM device /dev/$_name detected."
 
@@ -254,7 +255,7 @@
 open_luks_part_with_encrypted_passphrase() {
     local luks_rawdev="$1"
 
-    while [ 1 ]; do
+    while true ; do
         # Unseal the passphrase
         cryptfs-tpm2 -q unseal passphrase -P auto -o "$TMP_DIR/$PASSPHRASE" 2>/dev/null
         local res=$?
@@ -278,13 +279,13 @@
 open_luks_part_with_typed_passphrase() {
     local luks_rawdev="$1"
     local i=1
-    for i in `seq $MAX_PASSPHRASE_RETRY_COUNT`; do
+    for i in $(seq $MAX_PASSPHRASE_RETRY_COUNT); do
         cryptsetup luksOpen --key-file - "$luks_rawdev" "$LUKS_NAME" &&
             print_verbose "The LUKS partition $luks_rawdev is opened with the typed passphrase" &&
             return 0
 
-        [ $(($MAX_PASSPHRASE_RETRY_COUNT - $i)) -ne 0 ] &&
-            print_warning "Passphrase incorrect. $(($MAX_PASSPHRASE_RETRY_COUNT - $i))-time remaining ..."
+        [ $((MAX_PASSPHRASE_RETRY_COUNT - i)) -ne 0 ] &&
+            print_warning "Passphrase incorrect. $((MAX_PASSPHRASE_RETRY_COUNT - i))-time remaining ..."
     done
 
     print_error "Failed to open the LUKS partition $luks_rawdev with the typed passphrase"
@@ -330,8 +331,9 @@
 mount_luks() {
     local err=0
 
-    mount -o "$ROOTFS_MODE" "/dev/mapper/$LUKS_NAME" "$ROOTFS_DIR" ||
-        (err=1 && [ -e "/dev/mapper/$LUKS_NAME" ] && cryptsetup luksClose "$LUKS_NAME")
+    mount -o "$ROOTFS_MODE" "/dev/mapper/$LUKS_NAME" "$ROOTFS_DIR" || {
+        err=1 && [ -e "/dev/mapper/$LUKS_NAME" ] && cryptsetup luksClose "$LUKS_NAME"
+    }
 
     return $err
 }
@@ -353,7 +355,7 @@
 
     [ $TPM_TIS_MODULE_LOADED -eq 1 ] && modprobe --quiet -r tpm_tis
     [ $TPM_CRB_MODULE_LOADED -eq 1 ] && modprobe --quiet -r tpm_crb    
-    [ ! -z "$TPM_DEVICE" ] && rm -f "$TPM_DEVICE" 2>/dev/null
+    [ -n "$TPM_DEVICE" ] && rm -f "$TPM_DEVICE" 2>/dev/null
 
     if [ $TMP_DIR_MOUNTED -eq 1 ]; then
         umount "$TMP_DIR" 2>/dev/null
@@ -363,8 +365,8 @@
     unset TSS2_TCTI
 }
 
-
-trap "trap_handler $?" SIGINT EXIT
+# 2: SIGINT, 0: EXIT
+trap 'trap_handler $?' 2 0
 
 # Detect the present of LUKS partition.
 
@@ -374,8 +376,7 @@
 ! parse_rootfs_dev_path rootfs_dev_path_type rootfs_dev_path_name && exit 1
 
 rootfs_is_luks=0
-get_rawdev $rootfs_dev_path_type $rootfs_dev_path_name rootfs_rawdev
-if [ $? -eq 0 ]; then
+get_rawdev "$rootfs_dev_path_type" "$rootfs_dev_path_name" rootfs_rawdev && {
     # Check whether the rootfs device is a LUKS partition.
     for luks_rawdev in $luks_rawdev_pathes; do
         [ "$rootfs_rawdev" = "$luks_rawdev" ] && rootfs_is_luks=1 && break
@@ -385,14 +386,14 @@
         print_info "The specified rootfs is not a LUKS partition"
         exit 1
     fi
-fi
+}
 
 # root=LABEL=xxx cannot be parsed until the LUKS partition is mounted.
-[ $rootfs_is_luks -eq 0 -a "$rootfs_dev_path_type" != "LABEL" ] &&
+[ $rootfs_is_luks -eq 0 ] && [ "$rootfs_dev_path_type" != "LABEL" ] &&
     print_error "Unable to locate the specified rootfs" && exit 1
 
 # Overwrite LUKS_NAME if root=LABEL=xxx is specified.
-[ $rootfs_is_luks -eq 0 -a "$rootfs_dev_path_type" = "LABEL" -a -n "$rootfs_dev_path_name" ] &&
+[ $rootfs_is_luks -eq 0 ] && [ "$rootfs_dev_path_type" = "LABEL" ] && [ -n "$rootfs_dev_path_name" ] &&
     LUKS_NAME="$rootfs_dev_path_name"
 
 # Make sure the plain passphrase will be saved in a RAM-based
@@ -432,13 +433,13 @@
 # Check whether the LUKS partition is specified in root=.
 err=1
 for luks_rawdev in $luks_rawdev_pathes; do
-    [ -n "$rootfs_rawdev" -a "$rootfs_rawdev" != "$luks_rawdev" ] && continue
+    [ -n "$rootfs_rawdev" ] && [ "$rootfs_rawdev" != "$luks_rawdev" ] && continue
  
-    ! map_luks $luks_rawdev $tpm_absent && break
+    ! map_luks "$luks_rawdev" $tpm_absent && break
     ! mount_luks && break
 
-    [ -z "$rootfs_rawdev" ] && ! get_rawdev $rootfs_dev_path_type \
-        $rootfs_dev_path_name rootfs_rawdev && {
+    [ -z "$rootfs_rawdev" ] && ! get_rawdev "$rootfs_dev_path_type" \
+        "$rootfs_dev_path_name" rootfs_rawdev && {
             umount "$ROOTFS_DIR" 2>/dev/null
             cryptsetup luksClose "$LUKS_NAME" 2>/dev/null
             continue
diff -ur --new-file '--exclude=.git' a/scripts/luks-setup.sh d/scripts/luks-setup.sh
--- a/scripts/luks-setup.sh	2020-12-01 15:21:10.228957565 +0000
+++ d/scripts/luks-setup.sh	2021-01-13 13:55:17.153042932 +0000
@@ -1,4 +1,4 @@
-#!/bin/bash
+#!/bin/sh
 
 # The wrapper script for the creation of LUKS partition
 #
@@ -46,6 +46,8 @@
 TPM_ABSENT=1
 TEMP_DIR=""
 
+PATH=$PATH:'/usr/sbin'
+
 print_critical() {
     printf "\033[1;35m"
     echo "$@"
@@ -104,12 +106,14 @@
         # With newer kernel, TPM device description file is renamed
         grep -q "TPM 2.0 Device" "/sys/class/tpm/$dev/device/firmware_node/description" 2>/dev/null &&
             tpm_absent=0 && break
+
+        # Support virtual TPM
+        ls "/sys/class/tpm/$dev/device/driver" 2> /dev/null | grep -q MSFT0101 && tpm_absent=0 && break
     done
 
     [ $tpm_absent -eq 1 ] && print_info "No TPM device found" && return 1
 
-    pgrep tpm2-abrmd >/dev/null
-    [ $? -ne 0 ] && {
+    ! pgrep tpm2-abrmd >/dev/null && {
         TPM2TOOLS_TCTI_NAME=device
         export TPM2TOOLS_DEVICE_FILE=/dev/tpm0
         TSS2_TCTI=device
@@ -137,9 +141,9 @@
 
     if [ $err -eq 0 ]; then
         ! cryptfs-tpm2 -q unseal passphrase -P auto -o "$passphrase" &&
-	    print_error "Unable to unseal the passphrase" && return 1
+        print_error "Unable to unseal the passphrase" && return 1
     else
-	print_error "Unable to contact the resource manager" && return 1
+        print_error "Unable to contact the resource manager" && return 1
     fi
 
     [ $RESOURCEMGR_STARTED -eq 1 ] && pkill tpm2-abrmd
@@ -265,7 +269,7 @@
 EOF
 }
 
-PROG_NAME=`basename $0`
+PROG_NAME=$(basename "$0")
 OPT_FORCE_CREATION=0
 OPT_UNMAP_LUKS=0
 OPT_NO_TPM=0
@@ -274,48 +278,48 @@
 OPT_MAP_EXISTING_LUKS=0
 OPT_NO_SETUP=0
 OPT_OLD_LOCKOUT_AUTH=""
-OPT_LOUCKOUT_AUTH=""
+OPT_LOCKOUT_AUTH=""
 
 while [ $# -gt 0 ]; do
     opt=$1
     case $opt in
         -d|--dev)
-            shift && option_check $1 && OPT_LUKS_DEV="$1"
+            shift && option_check "$1" && OPT_LUKS_DEV="$1"
             ;;
-	-N|--no-setup)
+        -N|--no-setup)
             OPT_NO_SETUP=1
             ;;
-	-n|--name)
-	    shift && option_check $1 && OPT_LUKS_NAME="$1"
-	    ;;
-	-m|--map-existing)
+        -n|--name)
+            shift && option_check "$1" && OPT_LUKS_NAME="$1"
+            ;;
+        -m|--map-existing)
             OPT_MAP_EXISTING_LUKS=1
             ;;
-	-f|--force)
-	    OPT_FORCE_CREATION=1
-	    ;;
-	-u|--unmap)
-	    OPT_UNMAP_LUKS=1
-	    ;;
-	-t|--no-tpm)
-	    OPT_NO_TPM=1
-	    ;;
-	-e|--evict-all)
-	    OPT_EVICT_ALL=1
-	    ;;
+        -f|--force)
+            OPT_FORCE_CREATION=1
+            ;;
+        -u|--unmap)
+            OPT_UNMAP_LUKS=1
+            ;;
+        -t|--no-tpm)
+            OPT_NO_TPM=1
+            ;;
+        -e|--evict-all)
+            OPT_EVICT_ALL=1
+            ;;
         --old-lockout-auth)
             shift && option_check "$1" && OPT_OLD_LOCKOUT_AUTH="$1"
             ;;
         --lockout-auth)
             shift && option_check "$1" && OPT_LOCKOUT_AUTH="$1"
             ;;
-	-V|--verbose)
-	    OPT_VERBOSE=1
-	    ;;
-	--version)
-	    print_info "$VERSION"
-	    exit 0
-	    ;;
+        -V|--verbose)
+            OPT_VERBOSE=1
+            ;;
+        --version)
+            print_info "$VERSION"
+            exit 0
+            ;;
         -h|--help)
             show_help "$PROG_NAME"
             exit 0
@@ -328,7 +332,8 @@
     shift
 done
 
-trap "trap_handler $?" SIGINT EXIT
+# 2: SIGINT, 0: EXIT
+trap 'trap_handler $?' 2 0
 
 OPT_LUKS_NAME="${OPT_LUKS_NAME:-$DEFAULT_ENCRYPTION_NAME}"
 
@@ -341,30 +346,29 @@
 [ x"$OPT_LUKS_DEV" = x"" ] && print_error "LUKS device is not specified" &&
     exit 1
 
-TEMP_DIR=`mktemp -d /dev/luks-setup.XXXXXX`
+TEMP_DIR=$(mktemp -d /dev/luks-setup.XXXXXX)
 print_verbose "Temporary directory created: $TEMP_DIR"
 [ ! -d "$TEMP_DIR" ] && print_error "Failed to create the temporary directory" &&
     exit 1
 
 if [ $OPT_NO_SETUP -eq 1 ] ; then
     if [ $OPT_MAP_EXISTING_LUKS -eq 1 ]; then
-	if ! is_luks_partition "$OPT_LUKS_DEV"; then
+        if ! is_luks_partition "$OPT_LUKS_DEV"; then
             print_info "$OPT_LUKS_DEV is not a LUKS partition"
             exit 1
-	fi
+        fi
 
-	if [ $OPT_NO_TPM -eq 0 ] ; then
-	    detect_tpm
-	    [ $? -eq 0 ] && {
+        if [ $OPT_NO_TPM -eq 0 ] ; then
+            detect_tpm && {
                 TPM_ABSENT=0
                 ! unseal_passphrase "$TEMP_DIR/passphrase" && exit 1
             }
-	fi
+        fi
 
-	! map_luks_partition "$OPT_LUKS_DEV" "$OPT_LUKS_NAME" \
+        ! map_luks_partition "$OPT_LUKS_DEV" "$OPT_LUKS_NAME" \
             "$TPM_ABSENT" "$TEMP_DIR" && exit 1
 
-	print_info "The LUKS partition $OPT_LUKS_NAME is created on $OPT_LUKS_DEV"
+        print_info "The LUKS partition $OPT_LUKS_NAME is created on $OPT_LUKS_DEV"
     fi
     exit 0
 fi
@@ -385,10 +389,11 @@
 print_critical "******************************************************************"
 echo
 
-read -p "Do you wish to continue? [y/n] " -n 1
+echo -n "Do you wish to continue? [y/n] "
+read answer
 echo
 
-if [[ ! $REPLY =~ ^[Yy]$ ]]; then
+if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
     print_info "Installation cancelled"
     exit 0
 else
@@ -396,14 +401,12 @@
 fi
 
 if [ $OPT_NO_TPM -eq 0 ]; then
-    detect_tpm
-    if [ $? -eq 0 ]; then
+    if detect_tpm ; then
         if [ $OPT_EVICT_ALL -eq 1 ]; then
-            cmd="tpm2_takeownership --clear"
+            cmd="tpm2_clear"
             [ -n "$OPT_OLD_LOCKOUT_AUTH" ] && cmd="${cmd} --oldLockPasswd $OPT_OLD_LOCKOUT_AUTH"
             [ -n "$OPT_LOCKOUT_AUTH" ] && cmd="${cmd} --LockPasswd $OPT_LOCKOUT_AUTH"
-            eval "$cmd"
-            if [ $? -ne 0 ]; then
+            if ! eval "$cmd" ; then
                 print_error "Failed to clear authorization values with the lockoutAuth specified"
                 exit 1
             fi
@@ -414,8 +417,8 @@
             cmd="tpm2_dictionarylockout --setup-parameters --max-tries 1 \
                      --recovery-time 0 --lockout-recovery-time 0"
             [ -n "$OPT_LOCKOUT_AUTH" ] && cmd="${cmd} --lockout-passwd $OPT_LOCKOUT_AUTH"
-            eval "$cmd"
-            if [ $? -ne 0 ]; then
+            
+            if ! eval "$cmd" ; then
                 print_error "Failed to set the default DA policy"
                 exit 1
             fi
